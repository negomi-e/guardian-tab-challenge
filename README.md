# Guardian-tab-challenge

During implementation, I choose to focus primarily on Accessibility, Browser Support, No JavaScript

# Accessibility

I decided to reorganise the HTML file to use semantically correct HTML elements. The use of semantic HTML is not only beneficial for screen readers and native keyboard accessibility, it is also lighter and easier to edit. This included using `<section>` and `<article>` instead of `<div>` where appropriate.


I felt it was important to display the tab options as `<nav>` elements. Each line was also given the role=”navigation” as some browsers don’t automatically apply it to `<nav>`. It is particularly useful to assist users in navigating between tabs using the Tab and Enter keys and I built an addEventListener for this purpose too. I also choose to code `<ul >` elements within the nav link to give full backwards compatibility, so that it will still be displayed correctly in older browsers.

For the tab panel content, I choose to use ol/li so the screen reader has a clear order in which to read. I choose to avoid using a table layout as it requires more markup and will be therefore more difficult to maintain in the future.

I also used aria-attributes such as aria-hidden and aria-selected. These are designed to make the interface easier for assistive technologies to read the page. For the tabs, it ensures that the other tabs are not only hidden visually in the css (display: non) but they also aren’t read by non-visual displays. 
In this instance, I wanted to ensure the minimal amount of HTML is generated by JavaScript for accessibility purposes, however to make it more reusable in the future, I would have to readjust my HTML and JS file. For example, each `<article>` could be built as a separate component. This would allow the panel to be more dynamic, you would be able to render more headlines and not just UK News, Sport and Travel and the Fetch call to PromiseAll wouldn’t be so complicated to debug. 
 
# Browser Support

I am aware that I have used ES6 Features such as Promises with the Fetch API, arrow functions and strict mode, despite their limitations and poor support across older browsers, with the aim to make my code more efficient.
To solve these issues of browser incompatibility, I would need to convert these ECMAScript 6 features to a version that will work in older browsers. The easiest solution would be to use a transpiler such as Babel;  unfortunately I didn’t get round to fully implementing it. 

For this task, I decided to use Fetch API as I am more familiar with its syntax. However I am aware that it is not yet supported by all browsers on the Guardian’s recommended Browser list such as Apple Safari +8 and Internet Explorer Edge. If I had more time I would have replaced it with the older XMLHttpRequest API format that is supported by all or used some Fetch API polyfills. 

Another common problem with Browser Support is CSS styling. In this project, I didn’t manage to spend much time on developing this area. In retrospect, I should have started with a Normalize.css style sheet as it offers more homogeneous development of an application. I only got as far as using a css-loader in my webpack.config.js. 


# No JavaScript
To offer greater support where JavaScript cannot run, I decided to use the build tool Webpack in conjunction with Babel, because it can bundle all your files into one document and it offers greater cross-browser compatibility. Webpack is probably too advanced for this application and something like Browserify could have worked just as easily and been quicker for me to apply. 

I look forward to further discussing this project and my choices for Testing and Reusability. 
